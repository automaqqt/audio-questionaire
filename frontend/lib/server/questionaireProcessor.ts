import prisma from '@/lib/prisma';
import fs from 'fs/promises'; // For reading the PDF to send
import path from 'path'; // For path joining
import { FormData } from 'formdata-node';
import { fileFromPath } from 'formdata-node/file-from-path';
import fetch from "node-fetch"
import  fileFrom  from 'undici';

const FASTAPI_BACKEND_URL = process.env.FASTAPI_BACKEND_URL || 'http://localhost:8000'; // Your FastAPI URL

interface FastAPIQuestionData {
  id: string; // This might be a temporary ID from LLM or index
  text: string;
  type?: string;
  minValue?: number;
  maxValue?: number;
  optionsText?: string;
  visualOptions?: string;
  audioPath?: string; // Web-accessible path provided by FastAPI
  // Add other fields FastAPI might return for a question
}

interface FastAPIProcessedData {
  title: string;
  description?: string;
  language: string;
  originalPdfFilename?: string;
  questions: FastAPIQuestionData[];
  _tempProcessingId?: string; // ID FastAPI used for directory structuring audio files
}

export const config = {
    api: {
      bodyParser: false, // very important when forwarding FormData
    },
  };

export async function processQuestionnaireViaFastAPI(
    questionnaireId: string,          // ID from Next.js Prisma DB
    localPdfPath: string,             // Path to the PDF saved by Next.js
    language: string,                 // Language selected by user
    originalFilename: string,         // Original filename of the PDF
    questionnaireCurrentTitle: string // Title given by user in Next.js form
) {
    console.log(`[Next.js Processor] Sending PDF to FastAPI for Q_ID: ${questionnaireId}, PDF: ${localPdfPath}`);
    
    // Update status in Next.js DB immediately
    await prisma.questionnaire.update({
        where: { id: questionnaireId },
        data: { processingError: "Processing initiated with FastAPI backend...", isProcessed: false },
    }).catch(e => console.error("[Next.js Processor] Failed to update initial processing status:", e));

    const formData = new FormData();
    try {
        const file = await fileFromPath(localPdfPath, originalFilename);
        formData.append('pdf_file', file);
        formData.append('title', questionnaireCurrentTitle); // Send the title from Next.js form
        formData.append('language', language);
        formData.append('nextjs_questionnaire_id', questionnaireId); 
        // questionnaire_temp_id is generated by FastAPI, so we don't send it from here.

        console.log(`[Next.js Processor] Calling FastAPI: ${FASTAPI_BACKEND_URL}/api/v1/processing/process-pdf-questionnaire`);
        console.log(file)

        const response = await fetch(`${FASTAPI_BACKEND_URL}/api/v1/processing/process-pdf-questionnaire`, {
            method: 'POST',
            body: formData as any, // TS workaround
            //headers: formData.getHeaders(), // `form-data` library handles Content-Type for multipart
        });


        if (!response.ok) {
            let errorDetail = `FastAPI request failed with status ${response.status}`;
            try {
                const errorData = await response.json();
                console.log(errorData)
            } catch (jsonError) {
                // If response is not JSON, use text
                errorDetail = await response.text() || errorDetail;
            }
            console.error(`[Next.js Processor] FastAPI error response: ${errorDetail}`);
            throw new Error(errorDetail);
        }
        //@ts-ignore
        const processedDataFromFastAPI: FastAPIProcessedData = await response.json();

        console.log(`[Next.js Processor] FastAPI processing success. Received title: ${processedDataFromFastAPI.title}`);
        console.log(`[Next.js Processor] Received ${processedDataFromFastAPI.questions?.length || 0} questions.`);

        // --- Save processed data to Next.js Prisma DB ---
        //@ts-ignore
        await prisma.$transaction(async (tx) => {
            // Update questionnaire with potentially refined title/desc from LLM via FastAPI
            await tx.questionnaire.update({
                where: { id: questionnaireId },
                data: { 
                    title: processedDataFromFastAPI.title,
                    description: processedDataFromFastAPI.description,
                    language: processedDataFromFastAPI.language, // FastAPI confirms/returns lang
                    originalPdfFilename: processedDataFromFastAPI.originalPdfFilename || originalFilename, // Use what FastAPI returns or original
                    // isProcessed and processingError will be set at the end
                }
            });

            // Clear existing questions and audio for this questionnaire before adding new ones
            await tx.preGeneratedAudio.deleteMany({ where: { question: { questionnaireId: questionnaireId } } });
            await tx.question.deleteMany({ where: { questionnaireId: questionnaireId } });

            let order = 0;
            for (const q_data of processedDataFromFastAPI.questions) {
                order++;
                const question = await tx.question.create({
                    data: {
                        questionnaireId: questionnaireId,
                        text: q_data.text,
                        type: q_data.type || 'scale', // Default from FastAPI if provided
                        order: order,
                        minValue: q_data.minValue,
                        maxValue: q_data.maxValue,
                        optionsText: q_data.optionsText,
                        visualOptions: q_data.visualOptions ? JSON.stringify(q_data.visualOptions) : undefined,
                    }
                });

                if (q_data.audioPath) { // This is the web-accessible path like /audio_cache/...
                    await tx.preGeneratedAudio.create({
                        data: {
                            questionId: question.id,
                            languageCode: processedDataFromFastAPI.language, // Use the overall language
                            audioPath: q_data.audioPath,
                            // audioType: "combined" // If you add this field in Prisma & FastAPI returns it
                        }
                    });
                }
            }

            await tx.questionnaire.update({
                where: { id: questionnaireId },
                data: { isProcessed: true, processingError: null }
            });
        });

        console.log(`[Next.js Processor] Successfully processed and saved questionnaire ${questionnaireId} using data from FastAPI.`);

    } catch (error: any) {
        console.error(`[Next.js Processor] Error during FastAPI call or DB update for ${questionnaireId}:`, error);
        await prisma.questionnaire.update({
            where: { id: questionnaireId },
            data: { isProcessed: false, processingError: `Processing error: ${error.message}` }
            //@ts-ignore
        }).catch(dbUpdateError => console.error(`[Next.js Processor] CRITICAL: Failed to update error state for questionnaire ${questionnaireId}:`, dbUpdateError));
        // Do not re-throw here if the API route already sent a 202 response.
        // This function is meant to run "in the background" relative to the client's HTTP request.
        // Errors should be logged and reflected in the questionnaire's status.
    } finally {
        // Clean up the locally saved PDF in Next.js after sending to FastAPI
        /* if (localPdfPath && await fs.stat(localPdfPath).catch(() => false)) {
            await fs.unlink(localPdfPath)
                .then(() => console.log(`[Next.js Processor] Deleted local temp PDF: ${localPdfPath}`))
                .catch(e => console.error(`[Next.js Processor] Failed to delete local temp PDF ${localPdfPath}:`, e));
        } */
    }
}